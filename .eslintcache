[{"/Users/pavelsemochkin/FE/React/sav/src/index.js":"1","/Users/pavelsemochkin/FE/React/sav/src/App.jsx":"2","/Users/pavelsemochkin/FE/React/sav/src/components/index.js":"3","/Users/pavelsemochkin/FE/React/sav/src/components/button/index.js":"4","/Users/pavelsemochkin/FE/React/sav/src/components/button/Button.jsx":"5","/Users/pavelsemochkin/FE/React/sav/src/Header.jsx":"6","/Users/pavelsemochkin/FE/React/sav/src/Footer.jsx":"7","/Users/pavelsemochkin/FE/React/sav/src/Main.jsx":"8","/Users/pavelsemochkin/FE/React/sav/src/components/unit/index.js":"9","/Users/pavelsemochkin/FE/React/sav/src/components/unit/Unit.jsx":"10","/Users/pavelsemochkin/FE/React/sav/src/components/number-input/index.js":"11","/Users/pavelsemochkin/FE/React/sav/src/components/number-input/NumberInput.jsx":"12","/Users/pavelsemochkin/FE/React/sav/src/utils/index.js":"13","/Users/pavelsemochkin/FE/React/sav/src/utils/utils.js":"14","/Users/pavelsemochkin/FE/React/sav/src/components/select/index.js":"15","/Users/pavelsemochkin/FE/React/sav/src/components/select/Select.jsx":"16"},{"size":220,"mtime":1609527869657,"results":"17","hashOfConfig":"18"},{"size":2360,"mtime":1610406307097,"results":"19","hashOfConfig":"18"},{"size":135,"mtime":1610213620259,"results":"20","hashOfConfig":"18"},{"size":31,"mtime":1609527651987,"results":"21","hashOfConfig":"18"},{"size":224,"mtime":1609849028312,"results":"22","hashOfConfig":"18"},{"size":746,"mtime":1610287309650,"results":"23","hashOfConfig":"18"},{"size":164,"mtime":1609679898748,"results":"24","hashOfConfig":"18"},{"size":682,"mtime":1610395281229,"results":"25","hashOfConfig":"18"},{"size":27,"mtime":1609535934989,"results":"26","hashOfConfig":"18"},{"size":225,"mtime":1610395244481,"results":"27","hashOfConfig":"18"},{"size":41,"mtime":1609849563473,"results":"28","hashOfConfig":"18"},{"size":312,"mtime":1609850050413,"results":"29","hashOfConfig":"18"},{"size":113,"mtime":1610041138177,"results":"30","hashOfConfig":"18"},{"size":5191,"mtime":1610397764179,"results":"31","hashOfConfig":"18"},{"size":31,"mtime":1610213592803,"results":"32","hashOfConfig":"18"},{"size":540,"mtime":1610287372622,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"ofp83r",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"36"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"/Users/pavelsemochkin/FE/React/sav/src/index.js",[],["68","69"],"/Users/pavelsemochkin/FE/React/sav/src/App.jsx",[],"/Users/pavelsemochkin/FE/React/sav/src/components/index.js",[],"/Users/pavelsemochkin/FE/React/sav/src/components/button/index.js",[],"/Users/pavelsemochkin/FE/React/sav/src/components/button/Button.jsx",[],"/Users/pavelsemochkin/FE/React/sav/src/Header.jsx",[],"/Users/pavelsemochkin/FE/React/sav/src/Footer.jsx",[],"/Users/pavelsemochkin/FE/React/sav/src/Main.jsx",[],"/Users/pavelsemochkin/FE/React/sav/src/components/unit/index.js",[],"/Users/pavelsemochkin/FE/React/sav/src/components/unit/Unit.jsx",[],"/Users/pavelsemochkin/FE/React/sav/src/components/number-input/index.js",[],"/Users/pavelsemochkin/FE/React/sav/src/components/number-input/NumberInput.jsx",[],"/Users/pavelsemochkin/FE/React/sav/src/utils/index.js",[],"/Users/pavelsemochkin/FE/React/sav/src/utils/utils.js",["70","71"],"/* Bubble sort: repeatedly swap the adjacent elements if \nthey are in wrong order */\nexport function* bubbleSort(arr) {\n  const length = arr.length;\n\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < length - i - 1; j++) {\n      if (arr[j].value > arr[j + 1].value) {\n        swap(arr, j, j + 1);\n        highlight(arr, j, j + 1);\n        yield arr;\n      }\n    }\n  }\n  return arr;\n}\n\n/* insertion sort: To sort an array of size n in ascending order:\n1: Iterate from arr[1] to arr[n] over the array.\n2: Compare the current element (key) to its predecessor.\n3: If the key element is smaller than its predecessor, compare it to the elements before.\nMove the greater elements one position up to make space for the swapped element. */\nexport function* insertionSort(arr) {\n  for (let i = 1; i < arr.length; i++) {\n    let j = i;\n    while (j > 0 && arr[j - 1].value > arr[j].value) {\n\t  swap(arr, j, j - 1);\n\t  highlight(arr,j,j-1)\n\t  j = j - 1;\n\t  yield arr;\n    }\n  }\n  return arr;\n}\n\n/* Selection sort: The algorithm divides the input list into two parts:\na sorted sublist of items which is built up from left to right at the front (left) of the list\nand a sublist of the remaining unsorted items that occupy the rest of the list. \nInitially, the sorted sublist is empty and the unsorted sublist is the entire input list. \nThe algorithm proceeds by finding the smallest (or largest, depending on sorting order) element \nin the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element \n(putting it in sorted order), and moving the sublist boundaries one element to the right. */\n/* iMin - current minimum (index of a current minimum item to be precise)\ni - current item (index of a current item) */\nexport function* selectionSort(arr) {\n  const length = arr.length;\n  for (let j = 0; j < length - 1; j++) {\n    let iMin = j;\n\n    for (let i = j + 1; i < length; i++) {\n      if (arr[i].value < arr[iMin].value) iMin = i;\n    }\n    if (iMin !== j) {\n\t  swap(arr, j, iMin);\n\t  highlight(arr,j,iMin);\n\t  yield arr;\n    }\n  }\n  return arr;\n}\n\n/* heap sort:\n1) Built max-heap (An almost complete binary tree in which the parent node \nis always greater than its children is called a max-heap.)\n2) Deleting the root element(and put it in last position)\n3) Heapify(fix the max-heap) */\nexport function* heapSort(arr) {\n  let length = arr.length;\n  for (let i = Math.floor(length / 2) - 1; i >= 0; i--) {\n    max_heapify(arr, i, length); //Building max heap\n  }\n  for (let i = length - 1; i >= 0; i--) {\n    swap(arr, 0, i); //Deleting root element\n\tmax_heapify(arr, 0, i); //Building max heap again\n\thighlight(arr,0,i)\n\tyield arr;\n  }\n  return arr;\n}\n\nfunction max_heapify(arr, i, length) {\n  let left = 2 * i; //Left child index\n  let right = 2 * i + 1; //Right child index\n  let maximum;\n  if (right < length) {\n    //Checks if right child exist\n    if (arr[left].value >= arr[right].value) {\n      //Compares children to find maximum\n      maximum = left;\n    } else {\n      maximum = right;\n    }\n  } else if (left < length) {\n    //Checks if left child exists\n    maximum = left;\n  } else return; //In case of no children return\n  if (arr[i].value < arr[maximum].value) {\n    //Checks if the largest child is greater than parent\n    swap(arr, i, maximum); //If it is then swap both\n    max_heapify(arr, maximum, length); //max-heapify again\n  }\n  return;\n}\n\n/* merge sort: \n1) Divide the unsorted list into n sublists, \neach containing one element (a list of one element is considered sorted).\n2) Repeatedly merge sublists to produce new sorted sublists\nuntil there is only one sublist remaining. This will be the sorted list. */\nexport function* mergeSort(arr) {\n  if (arr.length === 1) {\n    return arr;\n  }\n  const middle = Math.floor(arr.length / 2);\n  let left = arr.slice(0, middle);\n  let right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n  const arr = [];\n\n  while (left.length && right.length) {\n    if (left[0].value < right[0].value) {\n      arr.push(left.shift());\n    } else {\n      arr.push(right.shift());\n    }\n  }\n  return arr.concat(left).concat(right);\n}\n\n/* quick sort: It works by selecting a 'pivot' element from the array \nand partitioning the other elements into two sub-arrays, \naccording to whether they are less than or greater than the pivot. \nThe sub-arrays are then sorted recursively. */\nexport function* quickSort(arr, start, end) {\n  if (start >= end) {\n    return;\n  }\n  let index = partition(arr, start, end);\n  quickSort(arr, start, index - 1);\n  quickSort(arr, index + 1, end);\n  return arr;\n}\n\nfunction swap(arr, a, b) {\n  let temp = arr[a];\n  arr[a] = arr[b];\n  arr[b] = temp;\n}\n\nfunction partition(arr, start, end) {\n  let pivotIndex = start;\n  let pivotValue = arr[end];\n  for (let i = start; i < end; i++) {\n    if (arr[i].value < pivotValue.value) {\n\t  swap(arr, i, pivotIndex);\n\t  highlight(arr,i,pivotIndex);\n      pivotIndex++;\n    }\n  }\n  swap(arr, pivotIndex, end);\n  highlight(arr,pivotIndex,end)\n  return pivotIndex;\n}\n\nfunction highlight(arr, a, b) {\n  arr.forEach((item) => (item.color = \"#0088cc\"));\n  arr[a].color = \"red\";\n  arr[b].color = \"red\";\n}\n","/Users/pavelsemochkin/FE/React/sav/src/components/select/index.js",[],"/Users/pavelsemochkin/FE/React/sav/src/components/select/Select.jsx",[],{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","severity":1,"message":"77","line":110,"column":8,"nodeType":"78","messageId":"79","endLine":118,"endColumn":2},{"ruleId":"76","severity":1,"message":"77","line":137,"column":8,"nodeType":"78","messageId":"79","endLine":145,"endColumn":2},"no-native-reassign",["80"],"no-negated-in-lhs",["81"],"require-yield","This generator function does not have 'yield'.","FunctionDeclaration","missingYield","no-global-assign","no-unsafe-negation"]